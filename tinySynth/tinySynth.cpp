/*
==============================================================================
tinySynth.cpp - Copyright (C) 2016 Aldo Ciaccini

Description:
This module can be considered as the baseline Synthetizer of the tinySynth project.
It extends the audio processing capabilities implemented inside the 
tinySynthProcessor::processBlock().
Being based on the JUCE Synthetizer, tinySynth is able to generate a sound 
composed by a configurable number of polifony voices.
the tinySynth::renderNextBlock() handles the audio generation process for 
the incoming MIDI notes according to the number of active voices.  
Each voice produces an audio output generated by 3 indipendent oscillators
and according to:
- Oscillator parameters: waveform type, frequency, octave and gain
- LFO effects: vibrato and tremolo effects
- ADSR modifications: attach, decay, release and sustain
- Filters parameters: filtering and routing modifications
- Noise level
==============================================================================
Copyright:
The tinySynth architecture was inspired by the vstSynth project developed 
by Gabriel Olochwoszcz in 2012 under the terms of the GNU Public Lic. v.2.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
==============================================================================
*/


#include "tinySynth.h"

//==============================================================================
tinySynthSound::tinySynthSound() { }

//============================================================================
tinySynthVoice::tinySynthVoice(float* parameters) {localParameters = parameters;}

//==============================================================================
tinySynthVoice::~tinySynthVoice() { }

//==============================================================================
float tinySynthVoice::getParameter (int index) {return localParameters[index];}

//==============================================================================
bool tinySynthVoice::canPlaySound (SynthesiserSound* sound)
{
	return dynamic_cast <tinySynthSound*> (sound) != 0;
}

//==============================================================================
void tinySynthVoice::startNote (const int midiNoteNumber, const float velocity, 
								SynthesiserSound* sound, const int currrentPitchWheelPosition)
{
	freq = MidiMessage::getMidiNoteInHertz(midiNoteNumber); // get the frequency and the velocity of the MIDI note
	keyLevel = velocity; // velocity is in the range between 0.0f and 1.0f

	// set the oscillator frequency
	oscillator1.setFrequency((float)freq);
	oscillator2.setFrequency((float)freq);
	oscillator3.setFrequency((float)freq);

	// set the envelope times (attack, decay, sustain and release)
	envelope1.setAllTimes(	getParameter(adsr1AttackParam), getParameter(adsr1DecayParam), 
							getParameter(adsr1SustainParam)/10, getParameter(adsr1ReleaseParam));
	envelope2.setAllTimes(	getParameter(adsr2AttackParam), getParameter(adsr2DecayParam), 
							getParameter(adsr2SustainParam)/10, getParameter(adsr2ReleaseParam));
	envelope3.setAllTimes(	getParameter(adsr3AttackParam), getParameter(adsr3DecayParam), 
							getParameter(adsr3SustainParam)/10, getParameter(adsr3ReleaseParam));
	
	// inizialize the envelope internal status to ATTACK value
	envelope1.keyOn();
	envelope2.keyOn();
	envelope3.keyOn();
}

//==============================================================================
void tinySynthVoice::stopNote (const bool allowTailOff)
{   
	// set the envelop internal status to  RELEASE value
	envelope1.keyOff();
	envelope2.keyOff();
	envelope3.keyOff();
	clearCurrentNote();
}

//==============================================================================
void tinySynthVoice::pitchWheelMoved (const int newValue) { } // not implemented

//==============================================================================
void tinySynthVoice::controllerMoved (const int index, const int newValue) { } // not implemented


//==============================================================================
void tinySynthVoice::renderNextBlock (AudioSampleBuffer& outputBuffer, int startSample, int numSamples)
{
	//****** START <rendering block initialization> ******//
	// these parameters are updated per block not for each sample!
	// Initialize oscillators parameters: Level, Wave and Octave
	if (	true || 
			osc1Level!=getParameter(osc1LevelParam)			|| osc2Level!=getParameter(osc2LevelParam)			|| 	osc3Level!=getParameter(osc3LevelParam) || 	
			osc1Octave!=getParameter(osc1OctaveParam)		|| osc2Octave!=getParameter(osc2OctaveParam)		|| 	osc3Octave!=getParameter(osc3OctaveParam) || 		
			osc1Wave!=getParameter(osc1WaveParam)			|| osc2Wave!=getParameter(osc2WaveParam)			|| 	osc3Wave!=getParameter(osc3WaveParam) ||
			osc1SemiTone!=getParameter(osc1SemiToneParam )	|| osc2SemiTone!=getParameter(osc2SemiToneParam )	|| osc3SemiTone!=getParameter(osc3SemiToneParam ))
	{

		osc1Level=getParameter(osc1LevelParam); 	osc2Level=getParameter(osc2LevelParam); 	osc3Level=getParameter(osc3LevelParam);
		osc1Octave=getParameter(osc1OctaveParam); 	osc2Octave=getParameter(osc2OctaveParam); 	osc3Octave=getParameter(osc3OctaveParam);		
		osc1Wave=getParameter(osc1WaveParam); 		osc2Wave=getParameter(osc2WaveParam); 		osc3Wave=getParameter(osc3WaveParam);
		osc1SemiTone=getParameter(osc1SemiToneParam); 		osc2SemiTone=getParameter(osc2SemiToneParam); 		osc3SemiTone=getParameter(osc3SemiToneParam);
	
		setOscillatorParams(keyLevel*osc1Level, keyLevel*osc2Level,keyLevel*osc3Level,osc1Wave, osc2Wave, osc3Wave,
			osc1Octave, osc2Octave, osc3Octave, 
			osc1SemiTone, osc2SemiTone, osc3SemiTone);

	}
	// Initialize filters parameters: filter type (LP, HP, BP) and ADSR modulation depth 
	if (	filter1Type != getParameter(filter1TypeParam)				|| 	filter2Type != getParameter(filter2TypeParam) || 
			filter1EnvModDepth != getParameter(filter1EnvModDepthParam) || 	filter2EnvModDepth != getParameter(filter2EnvModDepthParam))
	{
		filter1Type=getParameter(filter1TypeParam);
		filter2Type=getParameter(filter2TypeParam);
		filter1EnvModDepth=getParameter(filter1EnvModDepthParam);
		filter2EnvModDepth=getParameter(filter2EnvModDepthParam);
		hpeq1Filter.setType(int(filter1Type));
		hpeq2Filter.setType(int(filter2Type));
		hpeq1Filter.setEnvModDepth(filter1EnvModDepth); 
		hpeq2Filter.setEnvModDepth(filter2EnvModDepth);
	}

	// Initialize LFO internal  variables
	lfo0.Frequency = 0.0f;	lfo0.Depth = 0.0f; 	lfo0.Destination = 0; 	lfo0.Wave = 0;
	if ((lfo1.Frequency = getParameter(lfo1FreqParam)) < 0.1f)
		lfo1.Frequency = 0.0f;
	lfo1.Depth = getParameter(lfo1DevParam);
	lfo1.Destination = getParameter(lfo1DestParam);
	lfo1.Wave = getParameter(lfo1WaveParam);
	
	if ((lfo2.Frequency = getParameter(lfo2FreqParam)) < 0.1f)
		lfo2.Frequency = 0.0f;
	lfo2.Depth = getParameter(lfo2DevParam);
	lfo2.Destination = getParameter(lfo2DestParam);
	lfo2.Wave = getParameter(lfo2WaveParam);
	//****** END <rendering block initialization> ******//

	
	//****** START <rendering block loop> ******//
	// Pointer to buffer
	float* bufferPtr1 = outputBuffer.getSampleData(0,startSample);
	float oscOut1 = 0.0f, oscOut2 = 0.0f, oscOut3 = 0.0f;

	for (int currentSample = 0; currentSample < numSamples; ++currentSample)
	{
		//****** START <handling of oscillators outputs WRT noise level and LFO/ADSR assignations> ******//
		// oscillator 1 
		if (getParameter(osc1OnParam))
		{
			ADSR* envTemp = 0;
			switch((int) getParameter(osc1EnvParam))
			{
				case 0: envTemp = &envelope1; break;
				case 1: envTemp = &envelope2; break;
				case 2: envTemp = &envelope3; break;
			}
	
			LFO *lfoTemp = 0;
			switch((int) getParameter(osc1LfoParam))
			{
				case 0: lfoTemp = &lfo0; break;
				case 1: lfoTemp = &lfo1; break;
				case 2: lfoTemp = &lfo2; break;
			}
			oscOut1 = oscillator1.singleSample(envTemp, getParameter(noiseParam), lfoTemp);
		}

		// oscillator 2 
		if (getParameter(osc2OnParam))
		{
			ADSR* envTemp = 0;
			switch((int) getParameter(osc2EnvParam))
			{
				case 0: envTemp = &envelope1; break;
				case 1: envTemp = &envelope2; break;
				case 2: envTemp = &envelope3; break;
			}
	
			LFO *lfoTemp = 0;
			switch((int) getParameter(osc2LfoParam))
			{
				case 0: lfoTemp = &lfo0; break;
				case 1: lfoTemp = &lfo1; break;
				case 2: lfoTemp = &lfo2; break;
			}
			oscOut2 = oscillator2.singleSample(envTemp, getParameter(noiseParam), lfoTemp);
		}

		// oscillator 3 
		if (getParameter(osc3OnParam))
		{
			ADSR* envTemp = 0;
			switch((int) getParameter(osc3EnvParam))
			{
				case 0: envTemp = &envelope1; break;
				case 1: envTemp = &envelope2; break;
				case 2: envTemp = &envelope3; break;
			}

			LFO *lfoTemp = 0;
			switch((int) getParameter(osc3LfoParam))
			{
				case 0: lfoTemp = &lfo0; break;
				case 1: lfoTemp = &lfo1; break;
				case 2: lfoTemp = &lfo2; break;
			}
			oscOut3 = oscillator3.singleSample(envTemp, getParameter(noiseParam), lfoTemp);
		} //****** END <handling of oscillators outputs WRT noise level and LFO/ADSR assignations> ******//

		
		//****** START <handling of filters outputs WRT ADSR/LFO assignations and filters routing> ******//
		// handling of ADSR assignations
		ADSR* filter1_envTemp = 0;
		ADSR* filter2_envTemp = 0;
		switch((int) getParameter(filter1EnvParam))
		{
			case 0: filter1_envTemp = &envelope1; break;
			case 1: filter1_envTemp = &envelope2; break;
			case 2: filter1_envTemp = &envelope3; break;
		}
		
		switch((int) getParameter(filter2EnvParam))
		{
			case 0: filter2_envTemp = &envelope1; break;
			case 1: filter2_envTemp = &envelope2; break;
			case 2: filter2_envTemp = &envelope3; break;
		}
		
		// handling of LFO assignations
		LFO *filter1_lfoTemp = 0;
		LFO *filter2_lfoTemp = 0;
		switch((int) getParameter(filter1LfoParam))
		{
			case 0: filter1_lfoTemp = &lfo0; break;
			case 1: filter1_lfoTemp = &lfo1; break;
			case 2: filter1_lfoTemp = &lfo2; break;
		}
		
		switch((int) getParameter(filter2LfoParam))
		{
			case 0: filter2_lfoTemp = &lfo0; break;
			case 1: filter2_lfoTemp = &lfo1; break;
			case 2: filter2_lfoTemp = &lfo2; break;
		}
		
		// handling of filters routing
		const float input_to_filter = (oscOut1+oscOut2+oscOut3);
		float filter1_output = 0.0f;
		float filter2_output = 0.0f;
		const bool filter1_active = int(getParameter(filter1TypeParam)) != 3;
		const bool filter2_active = int(getParameter(filter2TypeParam)) != 3;
		
		if (filter1_active && !filter2_active) // only filter 1 is active
		{
			filter1_output = hpeq1Filter.singleSample(input_to_filter,  getParameter(filter1CutoffParam), 
				getParameter(filter1ResonanceParam), filter1_envTemp, filter1_lfoTemp);
			bufferPtr1[currentSample] += filter1_output; 
		}
		else if (filter2_active && !filter1_active) // only filter 2 is active
		{
			filter2_output = hpeq2Filter.singleSample(input_to_filter, getParameter(filter2CutoffParam), 
				getParameter(filter2ResonanceParam), filter2_envTemp, filter2_lfoTemp);
			bufferPtr1[currentSample] += filter2_output; 
		}
		else if (filter2_active && filter1_active) // both filters are active
		{
			// handles the filters cascade
			switch ((int) getParameter(filterSequenceParam))
			{
				case 0: // filters are working in parallel 
					filter1_output = hpeq1Filter.singleSample(input_to_filter,  getParameter(filter1CutoffParam), 
						getParameter(filter1ResonanceParam), filter1_envTemp, filter1_lfoTemp);
					filter2_output = hpeq2Filter.singleSample(input_to_filter, getParameter(filter2CutoffParam), 
						getParameter(filter2ResonanceParam), filter2_envTemp, filter2_lfoTemp);
					bufferPtr1[currentSample] += 0.5f*(filter2_output+filter1_output); 
					break; 
				case 1: // the ouput of filter 1 is routed to the input of filter 2
					filter1_output = hpeq1Filter.singleSample(input_to_filter,  getParameter(filter1CutoffParam), 
						getParameter(filter1ResonanceParam), filter1_envTemp, filter1_lfoTemp);
					filter2_output = hpeq2Filter.singleSample(filter1_output, getParameter(filter2CutoffParam), 
						getParameter(filter2ResonanceParam), filter2_envTemp, filter2_lfoTemp);
					bufferPtr1[currentSample] += filter2_output; 
				break; 
				case 2: // the ouput of filter 1 is routed to the input of filter 2
					filter2_output = hpeq2Filter.singleSample(input_to_filter,  getParameter(filter2CutoffParam), 
						getParameter(filter2ResonanceParam), filter2_envTemp, filter2_lfoTemp);
					filter1_output = hpeq1Filter.singleSample(filter2_output, getParameter(filter1CutoffParam), 
						getParameter(filter1ResonanceParam), filter1_envTemp, filter1_lfoTemp);
					bufferPtr1[currentSample] += filter1_output; 
				break; 
			}
		}
		else // no filters are active
		{
			bufferPtr1[currentSample] += (oscOut1+oscOut2+oscOut3);
		} //****** END <handling of filters outputs WRT ADSR/LFO assignations and filters routing> ******//
	
	} //****** END <rendering block loop> ******//

}


//==============================================================================
void tinySynthVoice::setOscillatorParams (float newGain1, float newGain2, float newGain3,
										 int newWaveform1,int newWaveform2,int newWaveform3,
										 int newOctave1, int newOctave2, int newOctave3,
										 int newSemiTone1, int newSemiTone2, int newSemiTone3)
{
	oscillator1.setGain(newGain1);
	oscillator2.setGain(newGain2);
	oscillator3.setGain(newGain3);
	
	oscillator1.setWaveform(newWaveform1);
	oscillator2.setWaveform(newWaveform2);
	oscillator3.setWaveform(newWaveform3);
	
	oscillator1.setOctave(newOctave1);
	oscillator2.setOctave(newOctave2);
	oscillator3.setOctave(newOctave3);
	
	oscillator1.setSemiTone(newSemiTone1);
	oscillator2.setSemiTone(newSemiTone2);
	oscillator3.setSemiTone(newSemiTone3);
}

